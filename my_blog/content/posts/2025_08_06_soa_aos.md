+++
title = "SOA와 AOS"
date = "2025-08-06"

[taxonomies]
tags = ["cs"]
+++

근래에 LLM이 떠오르며 SIMD 연산이 중요해지고 그에 따라 자연스럽게 데이터를 다루는 레이아웃을 고민하게 되었다. 여기엔 세가지가 있는데

- SoA(Structure of Arrays)
- AoS(Array of Structures)
- AoSoA(Array of Structures of Arrays)

각각의 레이아웃 장단점이 뭘까?

## SoA (Structure of Arrays)

SoA는 구조체 안에 배열을 담는 방식이다. 예를 들어, 다음과 같은 구조체가 있다고 하자.

```rust
const N: usize = 100;

struct Person {
    age: [i32; N],
    height: [f32; N],
}
```

이 방식은 다음과 같은 상황일 때 이점이 크다.
- SIMD 연산이 필요할 때 (벡터 집약 연산이 필요할 떄)
- 모든 데이터를 업데이트할 때 (CPU 캐시 히트율이 올라감)

단점도 있다.
- 구조체 단위 접근 시 불리 (캐시 히트율이 떨어짐)
- 가독성 저하 (코드 관리 및 데이터 관리가 어려움)

특수한 유즈케이스가 아니면 잘 쓰지 않는다.

## AoS (Array of Structures)

AoS는 구조체를 배열로 만드는 레이아웃 방법이다. 흔히 일반적인 개발자라면 많이 볼 수 있는 방법이다.

```rust
struct Person {
    age: i32,
    height: f32,
}

let people: Vec<Person> = vec![
    Person { age: 20, height: 170.0 },
    Person { age: 21, height: 175.0 },
    // ...
];
```

이 방식은 각각의 구조체에 접근할 때 효율이 좋다.

다만, 한번에 대량의 데이터에 접근하려면 모든 구조체에 접근해야 하기 떄문에 비효율적이다.

# AoSoA (Array of Structures of Arrays)

이건 위 두 방식의 장점을 합쳐 `SIMD` 연산에 특화된 설계 방식이다.

간단한데, SoA 방식을 사용하고 그걸 다시 AoS 방식으로 묶는 방법이다.

```rust
struct PersonBlock {
    age: [i32; 8],
    height: [f32; 8],
}

let people: Vec<PersonBlock> = vec![
    PersonBlock {
        age: [20, 21, 22, 23, 24, 25, 26, 27],
        height: [170.0, 175.0, 180.0, 185.0, 190.0, 195.0, 200.0, 205.0],
    },
    PersonBlock {
        age: [28, 29, 30, 31, 32, 33, 34, 35],
        height: [210.0, 215.0, 220.0, 225.0, 230.0, 235.0, 240.0, 245.0],
    },
    // ...
];
이렇게 하면 한번에 8개(256비트, SIMD 연산에 최적화됨)의 데이터에 접근할 수 있고, 모든 데이터를 업데이트할 때도 효율적이다.

또한 SoA 로 설계된 데이터에선 SIMD 연산을 할 때 직접 오프셋과 끝을 정해줘야 했는데, AoSoA 방식에서는 블록 단위로 자연스럽게 SIMD 연산이 가능하다는 장점이 있다.