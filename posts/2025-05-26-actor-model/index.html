<!DOCTYPE html>
<html lang="en" dir="auto">
<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>액터 모델</title>


<meta name="keywords" content="programming, hacking, security, coding, developer, develop">



<meta name="description" content="액터 모델의 핵심 원리와 장단점, 메시지 기반 동시성을 Rust 예제로 살펴봅니다.">





<link rel="canonical" href="https:&#x2F;&#x2F;wHoIsDReAmer.github.io&#x2F;blog&#x2F;posts&#x2F;2025-05-26-actor-model&#x2F;">


<link rel="stylesheet" href="https://wHoIsDReAmer.github.io/blog/css/includes/scroll-bar.css">
<link rel="stylesheet" href="https://wHoIsDReAmer.github.io/blog/css/styles.css">
<link rel="stylesheet" href="https://wHoIsDReAmer.github.io/blog/css/override.css">







<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }
    </style>
    
</noscript>



    
</head>
<body class=" dark" id="top">
    
    
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https:&#x2F;&#x2F;wHoIsDReAmer.github.io&#x2F;blog&#x2F;" accesskey="h" title="CWLog (Alt + H)">
                CWLog
            </a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch">
                    <li></li>
                </ul>
            </div>
        </div>
        
    </nav>
</header>

    
    <main class="main">
        
<article class="post-single">
  <header class="post-header">
      <div class="breadcrumbs">
          <a href="https:&#x2F;&#x2F;wHoIsDReAmer.github.io&#x2F;blog&#x2F;">Home</a>&nbsp;»&nbsp;
          <a href="https://wHoIsDReAmer.github.io/blog/posts/">Posts</a>&nbsp;»&nbsp;
          <a href="https:&#x2F;&#x2F;wHoIsDReAmer.github.io&#x2F;blog&#x2F;posts&#x2F;2025-05-26-actor-model&#x2F;">액터 모델</a>
      </div>
      <h1 class="post-title">액터 모델</h1>
      
      
      <div class="post-description">
          액터 모델의 핵심 원리와 장단점, 메시지 기반 동시성을 Rust 예제로 살펴봅니다.
      </div>
      
      
      <div class="post-meta">
      










<span title="2025-05-26 00:00:00 +0000">2025-05-26</span>&nbsp;·&nbsp;

      
      </div>
      
  </header>

  
  

<div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner">
            <ul>
                
                <li>
                    <a href="#aegteo-model" aria-label="액터 모델">액터 모델</a>
                    
                    <ul>
                    
                        <li>
                            <a href="#haegsim-weonri" aria-label="핵심 원리">핵심 원리</a>
                            
                        </li>
                    
                        <li>
                            <a href="#teugjing" aria-label="특징">특징</a>
                            
                        </li>
                    
                        <li>
                            <a href="#aegteoyi-haengdong" aria-label="액터의 행동">액터의 행동</a>
                            
                        </li>
                    
                        <li>
                            <a href="#jangjeom" aria-label="장점">장점</a>
                            
                        </li>
                    
                        <li>
                            <a href="#danjeom" aria-label="단점">단점</a>
                            
                        </li>
                    
                        <li>
                            <a href="#silje-sayong-sarye" aria-label="실제 사용 사례">실제 사용 사례</a>
                            
                        </li>
                    
                        <li>
                            <a href="#rustro-guhyeonhan-aegteo-model" aria-label="Rust로 구현한 액터 모델">Rust로 구현한 액터 모델</a>
                            
                        </li>
                    
                    </ul>
                    
                </li>
                
                <li>
                    <a href="#camjo" aria-label="참조">참조</a>
                    
                </li>
                
            </ul>
        </div>
    </details>
</div>


  

  
  <div class="post-content">
      <h2 id="aegteo-model">액터 모델<a class="anchor" aria-hidden="true" href="#aegteo-model" hidden="">#</a>
</h2>
<p>1973년 Carl Hewitt가 처음 제안한 모델로, 분산 시스템과 동시성 프로그래밍의 복잡성을 해결하기 위해 고안되었다.</p>
<p>액터 모델은 프로세스 간 통신을 추상화하여 동시성 프로그래밍을 단순화하는 모델이다.</p>
<p><code>모든 것은 actor다</code> 라는 철학을 바탕으로 나왔으며, <code>actor</code>마다 내부적으로 메시지를 주고받는 방식으로 동작한다. 메시지를 주고받는 방식으로 동작하기 때문에 메시지 큐를 사용하는 방식과 유사하다.</p>
<p>하나씩 톺아보자.</p>
<h3 id="haegsim-weonri">핵심 원리<a class="anchor" aria-hidden="true" href="#haegsim-weonri" hidden="">#</a>
</h3>
<p>액터 모델의 기본 아이디어는 다음과 같다:</p>
<ul>
<li><strong>액터(Actor)</strong>: 계산의 기본 단위로, 각자 독립된 상태와 행동을 가진다</li>
<li><strong>메시지 전달</strong>: 액터 간의 유일한 통신 수단으로, 비동기적으로 이루어진다</li>
<li><strong>불변성</strong>: 메시지는 불변이며, 액터의 상태는 외부에서 직접 접근할 수 없다</li>
</ul>
<h3 id="teugjing">특징<a class="anchor" aria-hidden="true" href="#teugjing" hidden="">#</a>
</h3>
<ul>
<li><strong>상태 캡슐화</strong>: 각 actor는 자신의 상태를 캡슐화하고 있으며, 외부에서 직접 접근할 수 없다.</li>
<li><strong>메시지 기반 통신</strong>: actor는 메시지를 통해서만 서로 통신한다.</li>
<li><strong>위치 투명성</strong>: actor는 로컬 또는 원격 위치를 구분하지 않고 메시지를 주고받는다.</li>
<li><strong>비동기 처리</strong>: 메시지 전송은 논블로킹이며, 응답을 기다리지 않는다.</li>
<li><strong>독립적 실행</strong>: 각 actor는 독립적으로 실행되며, 다른 actor의 실행에 영향을 받지 않는다.</li>
</ul>
<h3 id="aegteoyi-haengdong">액터의 행동<a class="anchor" aria-hidden="true" href="#aegteoyi-haengdong" hidden="">#</a>
</h3>
<p>액터가 메시지를 받았을 때 할 수 있는 일은 다음 세 가지뿐이다:</p>
<ol>
<li><strong>새로운 액터 생성</strong>: 다른 액터를 생성할 수 있다</li>
<li><strong>메시지 전송</strong>: 다른 액터에게 메시지를 보낼 수 있다</li>
<li><strong>상태 변경</strong>: 다음 메시지를 위해 자신의 상태를 변경할 수 있다</li>
</ol>
<h3 id="jangjeom">장점<a class="anchor" aria-hidden="true" href="#jangjeom" hidden="">#</a>
</h3>
<ul>
<li><strong>데드락 방지</strong>: 공유 상태가 없어 데드락이 발생하지 않는다</li>
<li><strong>확장성</strong>: 액터 수를 쉽게 늘려 시스템을 확장할 수 있다</li>
<li><strong>오류 격리</strong>: 한 액터의 실패가 다른 액터에 영향을 주지 않는다</li>
<li><strong>분산 처리</strong>: 네트워크를 통해 분산된 액터들이 투명하게 통신할 수 있다</li>
<li><strong>테스트 용이성</strong>: 각 액터를 독립적으로 테스트할 수 있다</li>
</ul>
<h3 id="danjeom">단점<a class="anchor" aria-hidden="true" href="#danjeom" hidden="">#</a>
</h3>
<ul>
<li><strong>디버깅 어려움</strong>: 비동기 메시지 전달로 인해 콜스택 추적이 어렵다</li>
<li><strong>메시지 순서</strong>: 메시지 전달 순서가 보장되지 않을 수 있다</li>
<li><strong>메모리 오버헤드</strong>: 각 액터마다 메일박스를 유지해야 한다</li>
</ul>
<h3 id="silje-sayong-sarye">실제 사용 사례<a class="anchor" aria-hidden="true" href="#silje-sayong-sarye" hidden="">#</a>
</h3>
<ul>
<li><strong>Erlang/OTP</strong>: 통신 시스템에서 수백만 개의 액터를 동시에 실행</li>
<li><strong>Akka</strong>: 대용량 트래픽을 처리하는 웹 서비스 (LinkedIn, Twitter 등)</li>
<li><strong>Orleans</strong>: Microsoft의 분산 게임 서버 플랫폼</li>
<li><strong>CAF</strong>: C++ 액터 프레임워크로 고성능 시스템 구축</li>
</ul>
<hr />
<p>사실 설명만 들으면 직접적으로 와닿지 않는다. 결국 최상위 추상화 레벨에서의 설명이기 때문이다. 실제로 구현해보면 그렇게 어렵지는 않다.</p>
<p>또한, 뮤텍스를 안쓴다고는 하는데, 내부 구현에서는 뮤텍스를 사용한다 ㅋㅋ</p>
<p>단순히 락의 책임이 개발자에서 액터 모델로 넘어간 거 뿐이다.</p>
<p>그리고 구현할 때 애플리케이션 레이어에서 구현할텐데, 실제로는 이런식으로 쓰이는 디자인보다는 실제 노드 자체를 액터로 취급하고 노드 간 통신을 액터로 취급하는 경우가 더 많다. 그러니까, 분산 시스템에서 더 많이 채택되는 디자인이다.</p>
<p>우선 구현해보기 전 사진부터 보자.
<img src="https://labviewwiki.org/w/images/f/f7/Actor_Framework_Communication.png" alt="actor_model" /></p>
<h3 id="rustro-guhyeonhan-aegteo-model">Rust로 구현한 액터 모델<a class="anchor" aria-hidden="true" href="#rustro-guhyeonhan-aegteo-model" hidden="">#</a>
</h3>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::sync::mpsc::{</span><span style="color:#bf616a;">self</span><span>, Receiver, Sender};
</span><span style="color:#b48ead;">use </span><span>std::thread;
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">enum </span><span>CalculatorMessage {
</span><span>    Add { a: </span><span style="color:#b48ead;">f64</span><span>, b: </span><span style="color:#b48ead;">f64</span><span>, reply: Sender&lt;</span><span style="color:#b48ead;">f64</span><span>&gt; },
</span><span>    Multiply { a: </span><span style="color:#b48ead;">f64</span><span>, b: </span><span style="color:#b48ead;">f64</span><span>, reply: Sender&lt;</span><span style="color:#b48ead;">f64</span><span>&gt; },
</span><span>    Divide { a: </span><span style="color:#b48ead;">f64</span><span>, b: </span><span style="color:#b48ead;">f64</span><span>, reply: Sender&lt;Result&lt;</span><span style="color:#b48ead;">f64</span><span>, String&gt;&gt; },
</span><span>    GetHistory { reply: Sender&lt;Vec&lt;String&gt;&gt; },
</span><span>    Clear,
</span><span>    Stop,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">struct </span><span>CalculatorActor {
</span><span>    </span><span style="color:#bf616a;">receiver</span><span>: Receiver&lt;CalculatorMessage&gt;,
</span><span>    </span><span style="color:#bf616a;">history</span><span>: Vec&lt;String&gt;,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>CalculatorActor {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">receiver</span><span>: Receiver&lt;CalculatorMessage&gt;) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        CalculatorActor {
</span><span>            receiver,
</span><span>            history: Vec::new(),
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">run</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) {
</span><span>        </span><span style="color:#b48ead;">while let </span><span>Ok(message) = </span><span style="color:#bf616a;">self</span><span>.receiver.</span><span style="color:#96b5b4;">recv</span><span>() {
</span><span>            </span><span style="color:#b48ead;">match</span><span> message {
</span><span>                CalculatorMessage::Add { a, b, reply } =&gt; {
</span><span>                    </span><span style="color:#b48ead;">let</span><span> result = a + b;
</span><span>                    </span><span style="color:#bf616a;">self</span><span>.history.</span><span style="color:#96b5b4;">push</span><span>(format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> + </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> = </span><span style="color:#d08770;">{}</span><span>&quot;, a, b, result));
</span><span>                    </span><span style="color:#b48ead;">let </span><span>_ = reply.</span><span style="color:#96b5b4;">send</span><span>(result);
</span><span>                }
</span><span>                CalculatorMessage::Multiply { a, b, reply } =&gt; {
</span><span>                    </span><span style="color:#b48ead;">let</span><span> result = a * b;
</span><span>                    </span><span style="color:#bf616a;">self</span><span>.history.</span><span style="color:#96b5b4;">push</span><span>(format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> * </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> = </span><span style="color:#d08770;">{}</span><span>&quot;, a, b, result));
</span><span>                    </span><span style="color:#b48ead;">let </span><span>_ = reply.</span><span style="color:#96b5b4;">send</span><span>(result);
</span><span>                }
</span><span>                CalculatorMessage::Divide { a, b, reply } =&gt; {
</span><span>                    </span><span style="color:#b48ead;">if</span><span> b == </span><span style="color:#d08770;">0.0 </span><span>{
</span><span>                        </span><span style="color:#b48ead;">let </span><span>_ = reply.</span><span style="color:#96b5b4;">send</span><span>(Err(&quot;</span><span style="color:#a3be8c;">Division by zero</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()));
</span><span>                    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                        </span><span style="color:#b48ead;">let</span><span> result = a / b;
</span><span>                        </span><span style="color:#bf616a;">self</span><span>.history.</span><span style="color:#96b5b4;">push</span><span>(format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> / </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> = </span><span style="color:#d08770;">{}</span><span>&quot;, a, b, result));
</span><span>                        </span><span style="color:#b48ead;">let </span><span>_ = reply.</span><span style="color:#96b5b4;">send</span><span>(Ok(result));
</span><span>                    }
</span><span>                }
</span><span>                CalculatorMessage::GetHistory { reply } =&gt; {
</span><span>                    </span><span style="color:#b48ead;">let </span><span>_ = reply.</span><span style="color:#96b5b4;">send</span><span>(</span><span style="color:#bf616a;">self</span><span>.history.</span><span style="color:#96b5b4;">clone</span><span>());
</span><span>                }
</span><span>                CalculatorMessage::Clear =&gt; {
</span><span>                    </span><span style="color:#bf616a;">self</span><span>.history.</span><span style="color:#96b5b4;">clear</span><span>();
</span><span>                    println!(&quot;</span><span style="color:#a3be8c;">History cleared</span><span>&quot;);
</span><span>                }
</span><span>                CalculatorMessage::Stop =&gt; {
</span><span>                    println!(&quot;</span><span style="color:#a3be8c;">Calculator stopping...</span><span>&quot;);
</span><span>                    </span><span style="color:#b48ead;">break</span><span>;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Clone)]
</span><span style="color:#b48ead;">struct </span><span>CalculatorHandle {
</span><span>    </span><span style="color:#bf616a;">sender</span><span>: Sender&lt;CalculatorMessage&gt;,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>CalculatorHandle {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>() -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#b48ead;">let </span><span>(sender, receiver) = mpsc::channel();
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> actor = CalculatorActor::new(receiver);
</span><span>
</span><span>        thread::spawn(</span><span style="color:#b48ead;">move </span><span>|| {
</span><span>            actor.</span><span style="color:#96b5b4;">run</span><span>();
</span><span>        });
</span><span>
</span><span>        CalculatorHandle { sender }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">add</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">a</span><span>: </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#bf616a;">b</span><span>: </span><span style="color:#b48ead;">f64</span><span>) -&gt; </span><span style="color:#b48ead;">f64 </span><span>{
</span><span>        </span><span style="color:#b48ead;">let </span><span>(reply_sender, reply_receiver) = mpsc::channel();
</span><span>        </span><span style="color:#b48ead;">let </span><span>_ = </span><span style="color:#bf616a;">self</span><span>.sender.</span><span style="color:#96b5b4;">send</span><span>(CalculatorMessage::Add { a, b, reply: reply_sender });
</span><span>        reply_receiver.</span><span style="color:#96b5b4;">recv</span><span>().</span><span style="color:#96b5b4;">unwrap_or</span><span>(</span><span style="color:#d08770;">0.0</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">multiply</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">a</span><span>: </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#bf616a;">b</span><span>: </span><span style="color:#b48ead;">f64</span><span>) -&gt; </span><span style="color:#b48ead;">f64 </span><span>{
</span><span>        </span><span style="color:#b48ead;">let </span><span>(reply_sender, reply_receiver) = mpsc::channel();
</span><span>        </span><span style="color:#b48ead;">let </span><span>_ = </span><span style="color:#bf616a;">self</span><span>.sender.</span><span style="color:#96b5b4;">send</span><span>(CalculatorMessage::Multiply { a, b, reply: reply_sender });
</span><span>        reply_receiver.</span><span style="color:#96b5b4;">recv</span><span>().</span><span style="color:#96b5b4;">unwrap_or</span><span>(</span><span style="color:#d08770;">0.0</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">divide</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">a</span><span>: </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#bf616a;">b</span><span>: </span><span style="color:#b48ead;">f64</span><span>) -&gt; Result&lt;</span><span style="color:#b48ead;">f64</span><span>, String&gt; {
</span><span>        </span><span style="color:#b48ead;">let </span><span>(reply_sender, reply_receiver) = mpsc::channel();
</span><span>        </span><span style="color:#b48ead;">let </span><span>_ = </span><span style="color:#bf616a;">self</span><span>.sender.</span><span style="color:#96b5b4;">send</span><span>(CalculatorMessage::Divide { a, b, reply: reply_sender });
</span><span>        reply_receiver.</span><span style="color:#96b5b4;">recv</span><span>().</span><span style="color:#96b5b4;">unwrap_or</span><span>(Err(&quot;</span><span style="color:#a3be8c;">Communication error</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()))
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_history</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; Vec&lt;String&gt; {
</span><span>        </span><span style="color:#b48ead;">let </span><span>(reply_sender, reply_receiver) = mpsc::channel();
</span><span>        </span><span style="color:#b48ead;">let </span><span>_ = </span><span style="color:#bf616a;">self</span><span>.sender.</span><span style="color:#96b5b4;">send</span><span>(CalculatorMessage::GetHistory { reply: reply_sender });
</span><span>        reply_receiver.</span><span style="color:#96b5b4;">recv</span><span>().</span><span style="color:#96b5b4;">unwrap_or_default</span><span>()
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">clear</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) {
</span><span>        </span><span style="color:#b48ead;">let </span><span>_ = </span><span style="color:#bf616a;">self</span><span>.sender.</span><span style="color:#96b5b4;">send</span><span>(CalculatorMessage::Clear);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">stop</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) {
</span><span>        </span><span style="color:#b48ead;">let </span><span>_ = </span><span style="color:#bf616a;">self</span><span>.sender.</span><span style="color:#96b5b4;">send</span><span>(CalculatorMessage::Stop);
</span><span>    }
</span><span>}
</span></code></pre>
<p>분산 시스템이나 실시간 시스템, 높은 동시성이 필요한 시스템에서 좋게 써먹을 수 있다. 성능적으로도 그렇고 디자인적으로도 우수하다.</p>
<h2 id="camjo">참조<a class="anchor" aria-hidden="true" href="#camjo" hidden="">#</a>
</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a></li>
</ul>

  </div>
  

  <footer class="post-footer">
      
      <ul class="post-tags">
          
          
          <li><a href="https:&#x2F;&#x2F;wHoIsDReAmer.github.io&#x2F;blog&#x2F;tags&#x2F;actor&#x2F;">actor</a></li>
          
          
          <li><a href="https:&#x2F;&#x2F;wHoIsDReAmer.github.io&#x2F;blog&#x2F;tags&#x2F;asynchronous&#x2F;">asynchronous</a></li>
          
          
          <li><a href="https:&#x2F;&#x2F;wHoIsDReAmer.github.io&#x2F;blog&#x2F;tags&#x2F;concurrency&#x2F;">concurrency</a></li>
          
      </ul>
      

    
    


<nav class="paginav">
    
    <a class="prev" href="https:&#x2F;&#x2F;wHoIsDReAmer.github.io&#x2F;blog&#x2F;posts&#x2F;2025-05-17-pipeline-pattern&#x2F;">
        <span class="title">« Prev</span>
        <br>
        <span>파이프라인 패턴</span>
    </a>
    
    
    <a class="next" href="https:&#x2F;&#x2F;wHoIsDReAmer.github.io&#x2F;blog&#x2F;posts&#x2F;2025-05-27-go-compile-time-variable-injection&#x2F;">
        <span class="title">Next »</span>
        <br>
        <span>Go의 Compile-Time Variable Injection</span>
    </a>
    
</nav>


    
  </footer>

</article>

    </main>
    
    <footer class="footer">
    
    <span>&copy; 2025 <a href="https:&#x2F;&#x2F;wHoIsDReAmer.github.io&#x2F;blog&#x2F;"></a></span>
    
    <span>
        Powered by
        <a href="https://www.getzola.org/" rel="noopener noreferrer" target="_blank">Zola</a> &
        <a href="https://github.com/cydave/zola-theme-papermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>



<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>


<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>



<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>


<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';
        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                var content = codeblock.textContent;
                if(codeblock.firstChild.tagName == 'TABLE') {
                    content = Array(...codeblock.firstChild.getElementsByTagName('span')).map((span) => { return span.textContent; }).join('');
                }
                navigator.clipboard.writeText(content);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            // td containing LineNos
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            // table containing LineNos and code
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            // code blocks not having highlight as parent class
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>



    
</body>
</html>
